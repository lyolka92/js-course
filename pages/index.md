# Software Development Life Cycle

Изучите материалы, представленные в разделе, включая ссылки на сторонние материалы.

## SDLC

**SDLC** – Software Development Life Cycle – жизненный цикл разработки ПО.

Что это такое и для чего этот жизненный цикл нужен? Это модель, определяющая структуру процесса разработки ПО. Следуя этой модели, каждый из участников разработки может понять:

- Кто участвует в разработке? Роли, стейкхолдеры (заинтересованные лица).
- Что ему делать? Задачи и обязанности. 
- Когда это делать? Фазы разработки, переход к следующей фазе. 
- Как всё это организовывать и контролировать? 
- Что должно получиться на выходе? Артефакты, документация, сам продукт 
- Как проверить, что получилось именно то, что надо?

Чтобы ответить на эти вопросы, и была разработана модель жизненного цикла. Можно сравнить её с пошаговой инструкцией, описывающей последовательные действия, которые нужно выполнить, чтобы достигнуть определённой цели. Следуя этой инструкции, мы каждый раз сможем получить стабильный и ожидаемый результат.

Согласно ей, весь процесс разработки делится на фазы, в каждую из которых выполняются определённые задачи, следующие обозначенным целям фазы. Фазы могут по-разному называться в разных источниках, разбиваться на более мелкие части, но общий смысл остаётся один.

### Основные роли на проекте

Роль описывает, за что отвечает данный участник процесса, и какие у него обязанности. Основные роли в процессе разработки: менеджер, аналитик, разработчик, тестировщик, саппорт. Особняком стоит Заказчик. Некоторые роли опциональные: саппорт и аналитик, например, могут отсутствовать. Тогда их роль выполняют другие члены команды. Например, анализ может проводиться со стороны заказчика, а иногда за это берутся тестировщики.

**Project Manager** (менеджер проекта) – тот, кто управляет проектом, планирует и рассчитывает временные рамки, количество необходимых ресурсов (бюджета, оборудования, людей), и кто отвечает перед заказчиком за проект.

**Analyst** (аналитик) – общается с заказчиком и с командой, уточняет и разрабатывает требования, переводит их с бизнес-языка на язык технический. Он должен отлично понимать бизнес-логику разрабатываемого продукта – что, с точки зрения бизнеса, продукт должен делать. Аналитик же описывает, как продукт должен это делать. Аналитиков может быть несколько, например, по разным областям разрабатываемого приложения.

**Developer** (разработчик) – делает оценки своей работы (сколько времени понадобится на выполнение той или иной задачи), пишет код, реализует приложение, фиксит найденные баги. Разработчиков обычно бывает несколько, главный разработчик – Dev Lead – координирует их работу, выполняет стратегические задачи по разработке, планирование, делает общие оценки по разработке в целом.

**Tester** (тестировщик, также иногда называется QA) – планирует и продумывает тестирование, делает оценки своей работы, используемые уровни и типы тестирования, пишет тесткейсы и выполняет их, создаёт тестовую документацию, коммуницирует с девелоперами, аналитиками, заказчиком, пишет репорты по результатам тестирования, ретестит исправленные баги, принимает решение, готов ли продукт и соответствует ли он критериям качества. В команде из нескольких тестировщиков обычно бывает Test Lead, который координирует их работу, продумывает Test Plan (план тестирования), стратегию тестирования, может назначать конкретные задачи тестировщикам, делать общие оценки по задачам всей команды тестирования.

**Отличие тестера от QA:** тестер выполняет Quality Control (контроль качества), обычно исключительно на стадии тестирования. Он производит валидацию – проверку, насколько разработанный продукт соответствует требованиям заказчика. QA выполняет Quality Assurance (обеспечение качества), и участвует не только в фазе тестирования, но и в других фазах, проверяя заранее, правильно ли разрабатывается продукт по требованиям. Кроме валидации, он производит верификацию – проверяя планы, требования, дизайн, тест кейсы. В дальнейшем мы будем употреблять термин «тестировщик», в основном подразумевая QA.

### Фазы жизненного цикла

1. **Планирование.** На протяжении него выполняются высокоуровневые задачи: определение целей, для чего нужен продукт, сбор и анализ бизнес-требований заказчика. Роли: заказчик, менеджер проекта, аналитик.
2. **Определение требований.** На этой фазе уже окончательно проясняются и составляются пользовательские требования к поведению продукта – Software Requirements Specification (SRS). Они обязательно согласуются с заказчиком. Определяется окончательный объём работ – scope. Роли: заказчик, менеджер проекта, аналитик, иногда тестировщик тоже может быть подключен к этому.
3. **Дизайн системы.** Базируясь на требованиях, создаётся архитектура приложения, как лучше реализовать нужное поведение продукта на практике. Учитываются такие моменты, как необходимая надёжность приложения, ограничения времени и бюджета, риски, и в результате выбирается лучший дизайн из предложенных (архитектура модулей продукта, взаимодействия между ними, сама структура). Документ – Functional Design Specification (FDS), с которым в дальнейшем будут иметь дело разработчики. Роли: Solution Architect (архитектор решений), заказчик, аналитик, иногда разработчик.
4. **Имплементация (разработка продукта).** Начинается собственно разработка в соответствии с дизайном, утверждённым на предыдущей стадии. По детальному, хорошо продуманному дизайну при девелопменте возникает минимум проблем. Роли: разработчик, аналитик, тестировщик.
5. **Тестирование.** На ней проверяется разработанный продукт. Но неверно было бы думать, что участие тестировщика в процессе разработки ПО ограничивается только этой фазой. Как мы увидели раньше, тестировщик вовлекается практически во все фазы жизненного цикла. Основные роли: тестировщик, разработчик.
6. **Введение в эксплуатацию, сопровождение (поддержка).** Протестированный продукт выпускается в продакшн (то есть к использованию конечными пользователями). Перед этим его могут отдать на приемочное тестирование со стороны заказчика, в реальном бизнес окружении – UAT (User Acceptance Testing). В случае каких-то проблем техническая поддержка оказывает помощь пользователям.

## Методологии

Существуют различные вариации жизненного цикла разработки ПО, возникшие в зависимости от поставленных задач, специфики проекта. Рассмотрим основные из них.

![](/sdlc/methodologies.gif)

### Waterfall

**Waterfall** – водопадная (каскадная) методология. Исторически она самая старая. Называется так потому, что фазы следуют одна за другой, переход к следующей стадии возможет только по окончанию предыдущей, и нет возможности вернуться назад.

![](/sdlc/waterfall-stages.png)

#### Фазы

| Фаза | Содержание | Условие перехода к следующей фазе |
| --- | --- | --- |
| Анализ | Сбор требований, подготовка Software Requirements Specifications | Все необходимые фичи проанализированы и задокументированы |
| Дизайн | На основании требований продумывается архитектура приложения, дизайн баз данных, требования к оборудованию, создание прототипов ПО | Дизайн и прототипы завершены |
| Разработка | Разработка приложения, разбитого на мелкие части – юниты, и юнит тесты – тесты, выполняемые разработчиками для поиска низкоуровневых ошибок в коде | Все фичи разработаны |
| Интеграция и Тестирование | Все юниты собираются в целую систему и проводится собственно тестирование. Сюда входит и тестирование требований тестировщиками, и написание тесткейсов, и их прохождение, и прочие задачи тестировщика вплоть до завершения тестирования. | Все фичи протестированы и все баги закрыты |
| Введение в эксплуатацию | Поставка готового продукта – release, delivery, приёмка его заказчиком, и поддержка | - |

#### Важные особенности

**Фазы не пересекаются** между собой.
Особой коммуникации не требуется, так как фазы разделены, команда вполне может быть распределённой – тестировщик в одной локации, аналитик в другой, разработчик в третьей, и т.д.

Проект будет успешен, только если с самого начала всё делается идеально и вовремя. Если требования очень хороши, в дизайне всё учли. Поэтому по такой методологии работают на проектах, где время – не критичный фактор, и на тщательное создание требований будет достаточно времени: государственные, медицинские проекты.
Если же в требованиях есть ошибки, и найдутся они на стадии тестирования и релиза, их будет очень сложно и дорого исправить. Чем раньше находим ошибки – тем меньше стоимость их исправления. Минус данной методологии – нет возможности исправлять дефекты как можно раньше.

Оценки тут играют важную роль, **любой сдвиг по времени критичен**, так как приводит к сдвигу всех последующих фаз, а последний оплот качества у нас именно тестирование. Часто получается, что именно тестирование страдает и эту фазу сокращают, в результате в релиз идёт недостестированный продукт, что может привести к печальным последствиям.

В проектах по водопаду очень **сложно осуществлять какие-либо изменения**, т.к. всё уже согласовано на более ранних фазах, и любое изменение приведёт к необходимости полного пересмотра всего.

**Большой объём документации**, с которой приходится работать.

#### Преимущества и недостатки

Преимущества:
- больше внимания к качеству результата каждого из этапов, дополнительные quality gates
- требования чётко определены и не меняются
- практически всё задокументировано
- планы команды не подвержены внешним изменениям

Недостатки:
- ошибка может быть устранена только пока идёт соответствующая фаза
- не предполагает изменения требований в ходе разработки
- быстрая реакция на клиентский фидбек не возможна
- тестирование происходит довольно поздно
- много затрат времени на подготовку и чтение документации

### Iterative and incremental models

**Incremental model** – процесс, в котором разрабатываемая система разбивается на отдельные модули или компоненты, и они реализуются последовательно, интегрируясь в систему по мере готовности. В чистом виде инкрементальная разработка проста в планировании, но в условиях изменяющихся требований интеграция готовых инкрементов становится сложнее. Проще говоря, инкрементальный процесс нацелен на добавление новых компонентов.

**Iterative model** (Итеративная модель). Итерация в широком смысле слова – это повторение какой-либо последовательности действий, цикл. Процесс по этой модели начинается с разработки небольшого набора требований, на выходе получается жизнеспособный продукт, и постепенно, с каждой итерацией, добавляется реализация следующего набора требований, пока не охватим все требования и не получим готовый продукт. Итеративный процесс поддерживает изменения уже сделанного функционала.

Итеративный и инкрементальный подход не противоречат друг другу, напротив, в сочетании они работают лучше. Разбивая всю систему на инкременты и применяя к каждому из них итерации, мы таким образом делаем процесс одновременно более управляемым и более гибким для переработок. Кроме того, самая рискованная и ответственная часть инкрементной стратегии - интеграция - перестаёт быть таковой как раз благодаря итерационному процессу.

Разницу между инкрементальным и итеративным процессом легко понять, взяв за пример написание картины «Мона Лиза», как на приведённой картинке. В первом случае мы рисуем по полностью готовому кусочку картины – инкременту – за раз, но всю Мону Лизу увидим, только когда закончим со всеми инкрементами. Во втором случае – первый набросок мы улучшаем и дополняем каждую итерацию, можем вносить изменения в том, что уже нарисовали, но портрет вполне узнаваем и на промежуточных этапах.

![](/sdlc/iterative-vs-incremental.png)

В итеративной модели нет такого чёткого разделения фаз, как в водопадной, но в целом можно выделить отдельные этапы проекта:

| Фаза | Содержание |
| --- | --- |
| Моделирование и планирование | Делаются прототипы, прикидывается общий план и сроки проекта, расписание релизов, примерно что войдёт в каждую итерацию |
| Требования и их оценка | Пишутся Software Requirements Specifications на эту итерацию |
| Проектирование и разработка | Основной документ Functional Design Specification, по которому реализуется партия требований - производится собственно кодинг. Во время этого так же может подключаться тестирование требований по разработке и имплементации в процессе. |
| Тестирование | Как только разработка заканчивается и выпускается новый билд, начинается основная фаза тестирования, по итогам которой делается релиз |
| Релиз | Вывод реализованного билда в продакшен |
| Оценка текущего состояния проекта | Оценивается, где сейчас находится разработка проекта, насколько далеко всё продвинулось за эту итерацию, сравнивается с планом, рассматривается, что можно улучшить |

И дальше всё повторяется для новой части требований.

#### Agile (гибкие методологии)

Это целый набор методологий (например, Scrum, Kanban, ...), которые по сути относятся к подсемейству Итеративных методологий. Основным моментом в них является готовность к постоянным изменениям. Тут также присутствуют итерации, называемые спринты, довольно короткие (обычно 2-4 недели). В результате каждого спринта получается рабочий продукт, который демонстрируется заказчику.

Основные идеи (**ценности Agile**):
- Люди и их взаимодействия важнее, чем процессы и инструменты.
- Рабочий софт важнее, чем исчерпывающая документация
- Сотрудничество с клиентом важнее, чем контракт
- Готовность реагировать на изменения важнее следования чёткому плану

Но это только приоритеты, это не значит, что процессы, документация и т.п. вообще не нужны в аджайле.

**12 принципов Agile Manifesto**:
- удовлетворение клиента за счёт ранней и бесперебойной поставки ценного программного обеспечения
- приветствие изменений требований даже в конце разработки (это может повысить конкурентоспособность полученного продукта)
- частая поставка рабочего программного обеспечения (каждый месяц или неделю или ещё чаще)
- тесное, ежедневное общение заказчика с разработчиками на протяжении всего проекта
- проектом занимаются мотивированные личности, которые обеспечены нужными условиями работы, поддержкой и доверием
- рекомендуемый метод передачи информации — личный разговор (лицом к лицу)
- работающее программное обеспечение — лучший измеритель прогресса
- спонсоры, разработчики и пользователи должны иметь возможность поддерживать постоянный темп на неопределённый срок
- постоянное внимание улучшению технического мастерства и удобному дизайну
- простота — искусство не делать лишней работы
- лучшие технические требования, дизайн и архитектура получаются у самоорганизованной команды
- постоянная адаптация к изменяющимся обстоятельствам. Команда должна систематически анализировать возможные способы улучшения эффективности и соответственно корректировать стиль своей работы

##### Scrum

Роли – участники процесса:

**Product Owner** – человек, который является представителем заказчика, презентует его интересы.

**Development team** – собственно, команда разработки, в которую входят разработчики, тестировщики, аналитики, архитекторы, и т.д., ответственная за то, чтобы выдавать рабочий продукт. В идеале каждый член команды должен быть способен заменить любого другого, то есть высокие требования к профессионализму участников. Команда не должна быть большой (3-9 человек).

**Scrum Master** – организует и проводит скрам митинги, следит за тем, чтобы все было по процессу, всячески помогает команде.

![](/sdlc/scrum.png)

Процесс начинается с создания **User Stories**.
Юзер стори – это вид требований, используемый в аджайле. Она написана бизнес языком и определяет необходимую функциональность, которая имеет ценность для заказчика/пользователя. Строится по принципу “As a `role`, I want to `feature` so that `benefit`” (например, как пользователь, я хочу выгружать отчёт о покупаемых товарах, чтобы наглядно видеть, какие товары наиболее популярны).

Основные требования к стори:
- она должна быть независима от других
- может обсуждаться
- имеет ценность для заказчика
- может быть оценена
- невелика по объему
- тестируема

Если требуемая фича слишком большая (Epic), она разбивается на несколько маленьких.

**Definition of Done** – мы должны чётко понимать, когда задача выполнена. Поэтому формируются наборы критериев к стори, таске, итерации, по которым можно будеть чётко сказать, что это сделано и готово.

**Backlog** – основной список всех стори, с расставленными приоритетами. Приоритеты даются Продакт Оунером и могут пересматриваться в дальнейшем. Все новые возникшие требования попадают в бэклог, им выдаётся приоритет и грубая оценка (не в часах, а в пойнтах-эталонах). Бэклог периодически пересматривается и актуализируется на груминг митингах.

В начале каждого спринта проводится **Sprint Planning Meeting**, на котором продакт оунер ревьюит стори с наивысшим приоритетом и команда вместе с ним выбирают какие стори взять на разработку в этот спринт. Стори разбиваются на небольшие таски (чтобы выполнение таски заняло не больше одного дня) и оцениваются. Из выбранных на спринт стори команда составляет **Sprint Backlog**.

Каждый день проводится небольшой митинг – **Daily Scrum**. Все рассказывают свой статус и слушают других. В статусе нужно ответить на 3 вопроса: Что я сделал за прошедший день? Что я планирую сделать сегодня? Какие возникли трудности? Скрам Мастер следит за тем, чтобы дейли митинг проходил всегда в одно и то же время и длился не более 15 минут, а также отслеживает возможные проблемы.

В процессе разработки, тестирования и багфиксинга на протяжении спринта очень хорошо, когда разработчик и тестер тесно взаимодействуют и работают в паре. Найденные баги могут быть пофикшены в эту итерацию, а могут превратиться в отдельные стори и быть также приоритизированы и занесены в бэклог.
Во время спринта тестируются новые фичи, проводится регрессионное тестирование уже существующего функционала и также часто используются автотесты.

И наконец в конце спринта проводится **Demo** – заказчику показывается, что мы разработали и как работает наш продукт.

По результатам спринта проводится **Retrospective Meeting** – члены команды обсуждают, что было сделано хорошо в прошедшем спринте, а что в процессе можно улучшить.

Материалы для самостоятельного изучения:
- https://www.scrum.org/resources/what-is-scrum
- http://unetway.com/tutorials/scrum/

##### Kanban

Kanban - это система управления бережливыми производством (перевод с японского: «сигнал»/«карточка»), которая использует информационные карточки для передачи заказа на всех этапах изготовления. Простыми словами, мы отслеживаем весь путь продукта, от идеи до выхода “на полку магазина”.

![](/sdlc/kanban.jpg)

Выше изображена kanban доска. Это основной инструмент отображения статуса по задачам. Главный принцип: мы видим на каком этапе производственного процесса находится та или иная задача. Плюс, отслеживается время на всех участках, то есть всегда можно обнаружить “узкие места” в системе и поработать с ними.

Количество столбцов вы определяете сами исходя из особенностей своего проекта. Важно, чтобы это были основные этапы, которые проходит ваш продукт.

Применение методологии весьма широкое. Kanban используют для реализации проектов, управления службой продаж, производственных линий, it-разработки и даже для организации собственной жизни.

**Принципы** kanban:
- Визуальное отображение задач. Все задачи должны быть представлены в виде карточек и отражены на доске. Очень важно обновлять статус задач. Например, если разработчики подготовили код и передали в тестирование, то карточка с задачей должна перейти в соответствующий столбец. Таким образом, любой участник команды в любой момент времени может посмотреть на каком этапе находится задача.
- Ограничение по столбцам WIP (work in progress или работу, выполняемую одновременно) на каждом этапе производства. Чтобы система рано или поздно не “захлебнулась” от потока задач, необходимо устанавливать ограничения. К примеру, на kanban доске выше в столбце Analisis (аналитика) у нас работают 2 человека и они могут обрабатывать не более 2 задач, нет смысла нагружать их больше, так как последующие этапы системы будут простаивать. Ограничение по столбцам подбираются опытным путем.
- Фокус на невыполненных задачах. Смотря на доску с задачами в первую очередь уделяйте внимание тем задачам, которые “подвисают” в том или ином столбце. Если у вас какой-то из этапов занимает больше всего времени, то попробуйте перераспределить ресурсы или же добавить людей, если есть такая возможность.
- Постоянное улучшение. Как только вы уравновесите нагрузку в системе, вам будет проще наблюдать за всем процессом в целом. Измеряйте время цикла (сколько задача висит в отдельном столбце, а сколько от момента попадания в To do, до релиза Done). Меняйте нагрузки в системе и сокращайте время на прохождение всех стадий.
- Уделяйте внимание мелочам. К примеру, если код, который пишут разработчики периодически не проходит тестирование и возвращается на доработку, то возможно, есть варианты улучшить качество разработки, чтобы в тест попадал более качественный продукт?

Материалы для самостоятельного изучения:
- https://www.planview.com/resources/articles/what-is-kanban/
- https://www.planview.com/resources/articles/kanban-vs-scrum/